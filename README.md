Обрабатываем выражение представленное в обратной польской нотации. 
Используя стек, в котором храним доп информацию, проходим по строке.
В качестве дополнительной информации храним множество возможных остатков количества 
букв х по модулю k.
1. Если обрабатываемый символ буква, то добавляем в стек {1} если это х и {0} иначе.
Ассимптотика обработки такого символа О(1)
2. Если обрабатываемый символ оператор +, то достаём из стека два верхних множества и
кладём обратно их объединение. (Действительно, слово лежащее в языке, заданном
суммой регулярных выражений может иметь любую кратность количества х по модулю k из
тех, которые были у слов, задаваемых сумируемыемыми регулярками)
Ассимптотика обработки такого символа О(k), тк в каждом множестве не больше k элементов.
3. Если обрабатываемый символ ., то то достаём из стека два верхних множества и
кладём обратно множество всех возможных сумм кратности из 1 множества и кратности из 2.
(Поскольку любое слово, задаваемое таким регулярным выражением - конкатенация слова из
языка, задаваймого первой регуляркой и слова из языка, задаваемого второй регуляркой)
Ассимптотика обработки такого символа О(k^2)
4. Если обрабатываемый символ *, то достаём из стека одно множество, находим НОД всех
его элементов и добавляем в стек множество, состоящее из всех возможных его степеней по
модулю k (их конечное число, поэтому можно перебрать все, пока не произойдёт зацикливание).
Корректность следует из существования ЛК а и b равной НОД(а, b) по модулю k.
Ассимптотика обработки такого символа:
О(log k) - время работы одного алгоритма Евклида
Количество его вызовов не более чем k.
И далее не более k операций умножения и взятия по модулю.
Итак асимптотика О(k * log k)
Ассимптотика работы всего алгоритма:
О(L*k^2), где L - длина регулярного выражения.